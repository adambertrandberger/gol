<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Game of Life</title>
    </head>
    <body>
        <canvas id="screen" width="1800" height="1000"></canvas>
        <div>
            <div>
                <label>Fast</label><input type="range" min="10" max="2000" value="300" id="delay"><label>Slow</label>
            </div>
            <div>
                <label>Small</label><input onchange="init()" type="range" min="5" max="100" value="20" id="size"><label>Big</label>
            </div>
            <div>
                <button onclick="toggleLoop()" id="loopStarter">Start Loop</button>
                <button onclick="runGeneration()">Next Generation</button>
                <label>Generation #</label><label id="generationCounter">0</label>
            </div>

            <div>
                <button onclick="save()">Save</button>
                <button onclick="load()">Load</button>
            </div>

        </div>
        <script>
         const canvas = document.getElementById('screen'),
               ctx = canvas.getContext('2d');

         let squareSize = 0,
             nx = 0,
             ny = 0,
             loopIsRunning = false,
             generationCount = 0,
             cells = [];
         init();
         load();

         class Vec2 {
             constructor(x, y) {
                 this.x = x;
                 this.y = y;
             }

             sub(o) {
                 return new Vec2(this.x-o.x, this.y-o.y);
             }

             hyp() {
                 return Math.sqrt(this.x*this.x + this.y*this.y);
             }
         }

         function distance(a, b) {
             const diff = a.sub(b);
             return Math.abs(diff.hyp());
         }

         // performance can be greatly improved
         // if the board is cut into halfs and only look
         // in the halfs where "v" could be (quadtree)
         function getClosestCell(v) {
             let closest = [0, 0],
                 closestDistance = Infinity;
             
             for (let i=0; i<nx; ++i) {
                 for (let j=0; j<ny; ++j) {
                     const pos = new Vec2((i*squareSize) + squareSize/2, (j*squareSize) + squareSize/2);
                     let d = distance(v, pos);
                     if (d < closestDistance) {
                         closest = [i, j];
                         closestDistance = d;
                     }
                 }
             }

             return closest;
         }

         function createCells() {
             const cells = [];
             for (let i=0; i<nx; ++i) {
                 const row = [];
                 for (let j=0; j<ny; ++j) {
                     row.push(0);
                 }
                 cells.push(row);
             }
             return cells;
         }

         function render() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             for (let i=0; i<nx; ++i) {
                 for (let j=0; j<ny; ++j) {
                     ctx.beginPath();
                     ctx.rect(i*squareSize, j*squareSize, squareSize, squareSize);
                     if (cells[i][j]) {
                         ctx.fill();
                     } else {
                         ctx.stroke();
                     }
                     ctx.closePath();
                 }
             }
         }

         function get(i, j) {
             if (i < 0 || j < 0 || i >= nx || j >= ny) {
                 return 0;
             }
             return cells[i][j];
         }

         function getNeighbors(i, j) {
             return [
                 get(i-1, j),
                 get(i-1, j-1),
                 get(i-1, j+1),
                 get(i, j-1),
                 get(i, j+1),
                 get(i+1, j-1),
                 get(i+1, j),
                 get(i+1, j+1)
             ];
         }

         function runGeneration() {
             const newCells = [];
             for (let i=0; i<nx; ++i) {
                 const row = [];
                 for (let j=0; j<ny; ++j) {
                     const neighbors = getNeighbors(i, j);
                     const sum = neighbors.reduce((a, b) => a + b, 0);
                     if (cells[i][j]) {
                         if (sum < 2 || sum > 3) {
                             row.push(0);
                         } else {
                             row.push(1);
                         }
                     } else {
                         if (sum === 3) {
                             row.push(1);
                         } else {
                             row.push(0);
                         }
                     }
                 }
                 newCells.push(row);
             }

             setGenerationCount(generationCount+1);
             cells = newCells;
             render();
         }

         function save() {
             localStorage.setItem('cells', JSON.stringify(cells));
         }

         function printSave() {
             console.log(localStorage.getItem('cells'));
         }

         function load() {
             const item = localStorage.getItem('cells');
             if (item) {
                 cells = JSON.parse(item);
             } else {
                 cells = createCells();
             }
             init();
         }

         canvas.onclick = function (e) {
             const pos = getRelativePosition(e);
             const [i, j] = getClosestCell(pos);
             cells[i][j] = cells[i][j] === 0 ? 1 : 0;
             setGenerationCount(0);
             render();
         }

         function getRelativePosition(e) {
             var rect = canvas.getBoundingClientRect();
             return new Vec2(event.clientX - rect.left, event.clientY - rect.top);
         }

         function resize(mat, x, y) {
             const resized = [];
             for (let i=0; i<x; ++i) {
                 const rows = [];
                 for (let j=0; j<y; ++j) {
                     if (i < mat.length && j < mat[i].length) {
                         rows.push(mat[i][j]);
                     } else {
                         rows.push(0);
                     }
                 }
                 resized.push(rows);
             }
             return resized;
         }

         function toggleLoop() {
             loopIsRunning = !loopIsRunning;
             if (loopIsRunning) {
                 loop();
                 window.loopStarter.innerText = 'End Loop';
             } else {
                 window.loopStarter.innerText = 'Start Loop';
             }
         }

         function init() {
             squareSize = +window.size.value;
             nx = canvas.width/squareSize;
             ny = canvas.height/squareSize;
             cells = resize(cells, nx, ny);
             render();
         }

         function setGenerationCount(gc) {
             generationCount = gc;
             window.generationCounter.innerText = generationCount;
         }
         
         function loop() {
             setTimeout(function () {
                 runGeneration();
                 render();
                 if (loopIsRunning) {
                     loop();
                 }
             }, window.delay.value);
         }
        </script>
    </body>
</html>
